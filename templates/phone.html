<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Cache busting meta tags to force browser reload -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>ðŸ“± Phone Simulator - VOIP System</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        
        .phone-container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .phone-screen {
            background: #000;
            border-radius: 30px;
            padding: 30px 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 5px solid #333;
        }
        
        .phone-header {
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
        }
        
        .call-display {
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 20px;
            padding: 30px 20px;
            text-align: center;
            color: #fff;
            margin-bottom: 30px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .caller-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3498db, #2980b9);
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
        }
        
        .caller-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .caller-number {
            font-size: 16px;
            color: #bdc3c7;
            margin-bottom: 20px;
        }
        
        .call-status {
            font-size: 18px;
            padding: 10px 20px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
        }
        
        .status-calling {
            background: #f39c12;
            animation: pulse 2s infinite;
        }
        
        .status-connected {
            background: #27ae60;
        }
        
        .status-ringing {
            background: #3498db;
            animation: pulse 2s infinite;
        }
        
        .status-ended {
            background: #e74c3c;
        }
        
        .phone-controls {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .btn-call {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }
        
        .btn-hangup {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }
        
        .btn-record {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
        }
        
        .btn-mute {
            background: linear-gradient(45deg, #34495e, #2c3e50);
        }
        
        .audio-controls {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .volume-control {
            margin: 15px 0;
        }
        
        .volume-slider {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }
        
        .dial-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .dial-btn {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dial-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .recording-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 15px;
            height: 15px;
            background: #e74c3c;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .call-timer {
            font-size: 16px;
            color: #bdc3c7;
            margin-top: 10px;
        }
        
        .audio-visualizer {
            height: 60px;
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 3px;
            margin: 20px 0;
        }
        
        .audio-bar {
            width: 4px;
            background: #3498db;
            border-radius: 2px;
            transition: height 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="phone-container">
        <div class="phone-screen">
            <!-- Recording Indicator -->
            <div id="recordingIndicator" class="recording-indicator" style="display: none;"></div>
            
            <!-- Phone Header -->
            <div class="phone-header">
                <h4><i class="fas fa-mobile-alt"></i> Phone Simulator</h4>
                <small>VOIP System Test</small>
            </div>
            
            <!-- Call Display -->
            <div class="call-display">
                <div class="caller-avatar">
                    <i class="fas fa-user"></i>
                </div>
                <div class="caller-name" id="callerName">VOIP System</div>
                <div class="caller-number" id="callerNumber">+1-555-0000</div>
                <div class="call-status status-calling" id="callStatus">Ready to Call</div>
                <div class="call-timer" id="callTimer" style="display: none;">00:00</div>
                
                <!-- Audio Visualizer -->
                <div class="audio-visualizer" id="audioVisualizer" style="display: none;">
                    <div class="audio-bar" style="height: 10px;"></div>
                    <div class="audio-bar" style="height: 20px;"></div>
                    <div class="audio-bar" style="height: 15px;"></div>
                    <div class="audio-bar" style="height: 30px;"></div>
                    <div class="audio-bar" style="height: 25px;"></div>
                    <div class="audio-bar" style="height: 40px;"></div>
                    <div class="audio-bar" style="height: 35px;"></div>
                    <div class="audio-bar" style="height: 20px;"></div>
                    <div class="audio-bar" style="height: 15px;"></div>
                    <div class="audio-bar" style="height: 25px;"></div>
                </div>
            </div>
            
            <!-- Phone Controls -->
            <div class="phone-controls">
                <button class="control-btn btn-call" id="callBtn" onclick="makeCall()">
                    <i class="fas fa-phone"></i>
                </button>
                <button class="control-btn btn-record" id="recordBtn" onclick="toggleRecording()" style="display: none;">
                    <i class="fas fa-microphone"></i>
                </button>
                <button class="control-btn btn-mute" id="muteBtn" onclick="toggleMute()" style="display: none;">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button class="control-btn btn-hangup" id="hangupBtn" onclick="hangupCall()" style="display: none;">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
            
            <!-- Test Controls -->
            <div class="text-center mb-3">
                <button class="btn btn-outline-light btn-sm" onclick="testMicrophoneSimple()" id="testMicBtn">
                    <i class="fas fa-microphone"></i> Test Microphone
                </button>
                <button class="btn btn-outline-warning btn-sm ms-2" onclick="forceRealAudio()" id="forceAudioBtn" style="display: none;">
                    <i class="fas fa-volume-up"></i> Force Real Audio
                </button>
                <button class="btn btn-outline-info btn-sm ms-2" onclick="testRecording()" id="testRecordBtn">
                    <i class="fas fa-record-vinyl"></i> Test 5s Recording
                </button>
                <button class="btn btn-outline-success btn-sm ms-2" onclick="playTestRecording()" id="playTestBtn" style="display: none;">
                    <i class="fas fa-play"></i> Play Test Audio
                </button>
                <button class="btn btn-outline-secondary btn-sm ms-2" onclick="initializeAudio()" id="initAudioBtn">
                    <i class="fas fa-cog"></i> Initialize Audio
                </button>
            </div>
            
            <!-- Audio Controls -->
            <div class="audio-controls" id="audioControls" style="display: none;">
                <div class="text-center mb-3">
                    <h6 class="text-white"><i class="fas fa-volume-up"></i> Audio Controls</h6>
                </div>
                <div class="volume-control">
                    <label class="text-white small">Microphone Volume</label>
                    <input type="range" class="volume-slider" id="micVolume" min="0" max="100" value="80">
                </div>
                <div class="volume-control">
                    <label class="text-white small">Speaker Volume</label>
                    <input type="range" class="volume-slider" id="speakerVolume" min="0" max="100" value="60">
                </div>
            </div>
            
            <!-- Dial Pad -->
            <div class="dial-pad" id="dialPad">
                <input type="text" class="form-control mb-3" id="phoneNumber" 
                       placeholder="Enter phone number..." value="09605104758"
                       style="grid-column: 1 / -1; background: rgba(255,255,255,0.1); border: none; color: white; text-align: center;">
                <button class="dial-btn" onclick="dialNumber('1')">1</button>
                <button class="dial-btn" onclick="dialNumber('2')">2</button>
                <button class="dial-btn" onclick="dialNumber('3')">3</button>
                <button class="dial-btn" onclick="dialNumber('4')">4</button>
                <button class="dial-btn" onclick="dialNumber('5')">5</button>
                <button class="dial-btn" onclick="dialNumber('6')">6</button>
                <button class="dial-btn" onclick="dialNumber('7')">7</button>
                <button class="dial-btn" onclick="dialNumber('8')">8</button>
                <button class="dial-btn" onclick="dialNumber('9')">9</button>
                <button class="dial-btn" onclick="dialNumber('*')">*</button>
                <button class="dial-btn" onclick="dialNumber('0')">0</button>
                <button class="dial-btn" onclick="dialNumber('#')">#</button>
            </div>
            
            <!-- Status Messages -->
            <div class="text-center">
                <div id="statusMessage" class="alert alert-info" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <!-- Modern MediaRecorder API for audio recording (built into browsers) -->
    <script>
        // ===== PHONE SIMULATOR JAVASCRIPT =====
        // Updated: 2025-08-22 09:15:00 - Added play buttons for test recordings to verify audio capture
        // This script uses the CORRECT endpoints: /phone-audio (not /audio)
        // Cache busting applied - clear browser cache if issues persist
        // Enhanced audio sending with fallback to ensure recordings always work
        // PRIORITY: Real microphone audio over generated audio
        // FIXED: Audio chunk clearing cycle that caused fallback to generated audio
        // REPLACED: Complex MediaRecorder wrapper with working test_mediarecorder.html implementation
        // FIXED: Audio sending loop continues after call ends (causing 404 errors)
        // ADDED: Critical safety checks to prevent sending audio with invalid call ID
        // ADDED: Test 5s Recording button to verify real audio capture functionality
        // ADDED: Play Test Audio button to verify captured audio quality
    </script>
    <script>
        let callActive = false;
        let recording = false;
        let muted = false;
        let callStartTime = null;
        let timerInterval = null;
        let currentCallId = null;
        let audioStream = null;
        let recorder = null; // Recorder.js instance
        let audioChunks = [];

        // Initialize WebSocket connection
        const socket = io();
        
        // Audio handling variables
        let audioContext;
        let isListening = false;
        let audioQueue = [];
        
        // WebSocket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            showStatus('Connected to VOIP system', 'success');
        });
        
        socket.on('call_answered', (data) => {
            console.log('Call answered by admin:', data);
            if (data.call_id === currentCallId) {
                // Call was answered by admin - start recording and update UI
                startCall();
            }
        });
        
        socket.on('admin_audio_received', (data) => {
            console.log('Received admin audio:', data);
            if (data.call_id === currentCallId) {
                // Play admin audio in real-time
                playIncomingAudio(data.audio_data);
            }
        });
        
        socket.on('call_audio_received', (data) => {
            console.log('Received caller audio:', data);
            if (data.call_id === currentCallId) {
                // This is our own audio being echoed back (ignore)
                console.log('Ignoring echoed audio from self');
            }
        });
        
        socket.on('audio_streams_update', (data) => {
            console.log('Audio streams update:', data);
            if (data.call_id === currentCallId) {
                showStatus(`Audio streams active - Caller: ${data.caller_audio_count}, Admin: ${data.admin_audio_count}`, 'info');
            }
        });
        
        // Handle call ended event (when admin hangs up)
        socket.on('call_ended', (data) => {
            console.log('Call ended event received:', data);
            if (data.call_id === currentCallId) {
                // Stop recording and update UI
                endCall();
                showStatus(`Call ended by admin: ${data.reason || 'unknown reason'}`, 'warning');
                
                console.log('Call terminated by admin, simulator stopped');
            }
        });
        
        // Play incoming audio from admin
        function playIncomingAudio(audioData) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Decode base64 audio
                const audioBytes = atob(audioData);
                const audioArray = new Uint8Array(audioBytes.length);
                for (let i = 0; i < audioBytes.length; i++) {
                    audioArray[i] = audioBytes.charCodeAt(i);
                }
                
                // Convert to audio buffer and play
                audioContext.decodeAudioData(audioArray.buffer, (buffer) => {
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                    
                    console.log('Playing admin audio:', buffer.duration, 'seconds');
                }, (error) => {
                    console.error('Error decoding admin audio:', error);
                });
            } catch (error) {
                console.error('Error playing incoming audio:', error);
            }
        }

        // Initialize audio recording with MediaRecorder API (modern browsers)
        async function initializeAudio() {
            try {
                // Check if getUserMedia is available
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    // Fallback for older browsers
                    navigator.mediaDevices = {};
                    navigator.mediaDevices.getUserMedia = function(constraints) {
                        const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                        
                        if (!getUserMedia) {
                            throw new Error('getUserMedia is not supported in this browser');
                        }
                        
                        return new Promise(function(resolve, reject) {
                            getUserMedia.call(navigator, constraints, resolve, reject);
                        });
                    };
                }
                
                // Check if MediaRecorder is available
                if (typeof MediaRecorder === 'undefined') {
                    throw new Error('MediaRecorder API not supported in this browser');
                }
                
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    } 
                });
                
                console.log('âœ… Microphone access granted');
                console.log('Audio stream tracks:', audioStream.getTracks().length);
                audioStream.getTracks().forEach((track, index) => {
                    console.log(`Track ${index}:`, track.kind, track.enabled, track.readyState);
                });
                
                // Create MediaRecorder with working configuration
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                    ? 'audio/webm;codecs=opus' 
                    : 'audio/webm';
                
                mediaRecorder = new MediaRecorder(audioStream, { 
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000  // 128kbps for better quality
                });
                audioChunks = [];
                
                console.log('MediaRecorder created with MIME type:', mimeType);
                console.log('MediaRecorder state:', mediaRecorder.state);
                
                // Set up MediaRecorder event handlers (working implementation)
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log(`ðŸŽ¤ Audio chunk captured: ${event.data.size} bytes, total chunks: ${audioChunks.length}`);
                        
                        // Also add to accumulated audio for sending
                        if (!window.accumulatedAudioChunks) {
                            window.accumulatedAudioChunks = [];
                        }
                        window.accumulatedAudioChunks.push(event.data);
                        console.log(`ðŸŽ¤ Added to accumulated audio: ${window.accumulatedAudioChunks.length} total accumulated chunks`);
                    }
                };
                
                mediaRecorder.onstart = () => {
                    console.log('âœ… MediaRecorder started recording');
                    console.log('ðŸŽ¤ Speak into your microphone now...');
                };
                
                mediaRecorder.onstop = () => {
                    console.log('â¹ï¸ MediaRecorder stopped recording');
                };
                
                mediaRecorder.onerror = (event) => {
                    console.error('âŒ MediaRecorder error:', event.error);
                };
                
                // Create a simple recorder object that works like the test version
                recorder = {
                    start: function() {
                        this.isRecording = true;
                        audioChunks = []; // Clear previous chunks
                        console.log('ðŸŽ¤ Starting MediaRecorder recording...');
                        mediaRecorder.start(1000); // Record in 1-second chunks for better WebM formation
                    },
                    stop: function() {
                        this.isRecording = false;
                        if (mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                        console.log('ðŸ›‘ MediaRecorder recording stopped');
                    },
                    pause: function() {
                        if (this.isRecording && mediaRecorder.state === 'recording') {
                            mediaRecorder.pause();
                            console.log('â¸ï¸ MediaRecorder paused');
                        }
                    },
                    resume: function() {
                        if (this.isRecording && mediaRecorder.state === 'paused') {
                            mediaRecorder.resume();
                            console.log('â–¶ï¸ MediaRecorder resumed');
                        }
                    },
                    destroy: function() {
                        this.isRecording = false;
                        audioChunks = [];
                        if (audioStream) {
                            audioStream.getTracks().forEach(track => track.stop());
                        }
                        console.log('ðŸ—‘ï¸ MediaRecorder destroyed');
                    },
                    exportWAV: function(callback) {
                        if (audioChunks.length > 0) {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            callback(audioBlob);
                        } else {
                            callback(new Blob([], { type: mimeType }));
                        }
                    },
                    isRecording: false,
                    audioChunks: audioChunks, // Direct reference to the working chunks array
                    mediaRecorder: mediaRecorder
                };
                
                console.log('âœ… Audio initialized successfully with working MediaRecorder API');
                showStatus('Microphone ready with working MediaRecorder API', 'success');
                
            } catch (error) {
                console.error('âŒ Error accessing microphone:', error);
                showStatus('Microphone access denied or not supported: ' + error.message, 'warning');
                
                // Create a mock recorder for testing without microphone
                try {
                    recorder = {
                        start: function() { console.log('Mock recorder started'); },
                        stop: function() { console.log('Mock recorder stopped'); },
                        pause: function() { console.log('Mock recorder paused'); },
                        resume: function() { console.log('Mock recorder resumed'); },
                        destroy: function() { console.log('Mock recorder destroyed'); },
                        exportWAV: function(callback) { 
                            callback(new Blob([], { type: 'audio/webm' }));
                        },
                        isRecording: false,
                        audioChunks: []
                    };
                    
                    console.log('Mock recorder created for testing without microphone');
                    showStatus('Mock recorder ready (no microphone access)', 'info');
                } catch (mockError) {
                    console.error('Error creating mock recorder:', mockError);
                    showStatus('Failed to create audio recorder', 'danger');
                }
            }
        }

        // Update audio visualizer with real audio data
        function updateAudioVisualizer(audioData) {
            const bars = document.querySelectorAll('.audio-bar');
            const dataArray = audioData.split(',').map(Number);
            
            bars.forEach((bar, index) => {
                if (index < dataArray.length) {
                    const height = Math.abs(dataArray[index]) / 128 * 40 + 10;
                    bar.style.height = height + 'px';
                }
            });
        }

        // Make call
        async function makeCall() {
            if (callActive) return;
            
            const phoneNumber = document.getElementById('phoneNumber').value;
            if (!phoneNumber) {
                showStatus('Please enter a phone number', 'warning');
                return;
            }
            
            try {
                // Ensure audio is initialized
                if (!recorder) {
                    await initializeAudio();
                    if (!recorder) {
                        showStatus('Audio recorder not available - call will proceed without recording', 'warning');
                        // Continue with call even without recording
                    }
                }
                
                // Simulate call creation
                const response = await fetch(`/simulate-call?number=${phoneNumber}`);
                const data = await response.json();
                
                if (data.success) {
                    currentCallId = data.call_id;
                    callActive = true;
                    callStartTime = new Date();
                    
                    // Join audio room for real-time communication
                    socket.emit('join_call_room', { call_id: currentCallId });
                    
                    // Update UI
                    document.getElementById('callStatus').textContent = 'Ringing...';
                    document.getElementById('callStatus').className = 'call-status status-ringing';
                    document.getElementById('callTimer').style.display = 'block';
                    document.getElementById('audioVisualizer').style.display = 'block';
                    document.getElementById('audioControls').style.display = 'block';
                    
                    // Show call controls
                    document.getElementById('callBtn').style.display = 'none';
                    document.getElementById('recordBtn').style.display = 'block';
                    document.getElementById('muteBtn').style.display = 'block';
                    document.getElementById('hangupBtn').style.display = 'block';
                    document.getElementById('dialPad').style.display = 'none';
                    document.getElementById('forceAudioBtn').style.display = 'inline-block';
                    
                    // Start timer and visualizer
                    startTimer();
                    startAudioVisualizer();
                    
                    showStatus(`Call initiated to ${phoneNumber} - Waiting for answer...`, 'success');
                    
                    // DO NOT start recording automatically - wait for admin to answer
                    // Recording will start when admin answers the call
                    
                } else {
                    showStatus('Failed to initiate call: ' + data.error, 'danger');
                }
            } catch (error) {
                console.error('Error making call:', error);
                showStatus('Error making call: ' + error.message, 'danger');
            }
        }

        // Start call (called when admin answers)
        function startCall() {
            if (!currentCallId) {
                console.error('No active call ID to start');
                return;
            }
            
            console.log('Starting call with ID:', currentCallId);
            
            // Update call status
            document.getElementById('callStatus').textContent = 'Call Active';
            document.getElementById('callStatus').className = 'call-status status-connected';
            
            // Start call timer
            callStartTime = Date.now();
            startTimer();
            
            // Show audio controls
            document.getElementById('audioControls').style.display = 'block';
            document.getElementById('callBtn').style.display = 'none';
            document.getElementById('hangupBtn').style.display = 'block';
            document.getElementById('dialPad').style.display = 'none';
            
            // Start recording automatically
            if (recorder && !recording) {
                startRecording();
            }
            
            // Start periodic audio sending
            startPeriodicAudioSending();
            
            console.log('Call started successfully for ID:', currentCallId);
        }

        // Start continuous audio streaming for recording
        function startContinuousAudioStreaming() {
            if (!recorder || !callActive) return;
            
            console.log('Starting continuous audio streaming with Recorder.js');
            
            // Start recording with Recorder.js
            recorder.start().then(() => {
                console.log('Recorder.js started successfully');
                
                // Set up periodic audio data extraction and sending
                startPeriodicAudioSending();
                
            }).catch((error) => {
                console.error('Error starting Recorder.js:', error);
                showStatus('Recording start failed: ' + error.message, 'danger');
            });
        }

        // Start periodic audio sending to ensure continuous recording
        function startPeriodicAudioSending() {
            if (!currentCallId || !callActive) return;
            
            console.log('ðŸŽ¤ Starting periodic audio sending for continuous recording...');
            console.log('Recorder state:', recorder ? 'Available' : 'Not available');
            console.log('Recorder isRecording:', recorder ? recorder.isRecording : 'N/A');
            console.log('Audio chunks count:', audioChunks ? audioChunks.length : 'N/A');
            
            // Start MediaRecorder if available
            if (recorder && recorder.mediaRecorder && !recorder.isRecording) {
                try {
                    recorder.start();
                    console.log('ðŸŽ¤ MediaRecorder started - capturing real microphone audio');
                } catch (error) {
                    console.error('âŒ Error starting MediaRecorder:', error);
                }
            }
            
            // Wait a moment for MediaRecorder to start capturing audio before sending
            setTimeout(() => {
                // Set up periodic audio data collection and sending
                const audioSendingInterval = setInterval(() => {
                    // CRITICAL: Check if call is still active before processing
                    if (!callActive || !currentCallId) {
                        console.log('ðŸ›‘ Call ended, stopping audio sending loop');
                        clearInterval(audioSendingInterval);
                        return;
                    }
                    
                    // Additional check: verify the call still exists in the DOM
                    const callStatusElement = document.getElementById('callStatus');
                    if (!callStatusElement || callStatusElement.textContent === 'Call Ended') {
                        console.log('ðŸ›‘ Call status indicates call ended, stopping audio loop');
                        clearInterval(audioSendingInterval);
                        callActive = false;
                        currentCallId = null;
                        return;
                    }
                    
                    try {
                        console.log('=== AUDIO SENDING LOOP ===');
                        console.log('Recorder available:', !!recorder);
                        console.log('Recorder isRecording:', recorder ? recorder.isRecording : 'N/A');
                        console.log('Audio chunks count:', audioChunks ? audioChunks.length : 'N/A');
                        
                        let audioSent = false;
                        
                        // Method 1: Try to get audio from MediaRecorder chunks (REAL MICROPHONE AUDIO)
                        if (audioChunks && audioChunks.length > 0) {
                            // Check if we have accumulated audio ready to send
                            if (window.accumulatedAudioChunks && window.accumulatedAudioChunks.length > 0) {
                                console.log('ðŸŽ¤ Sending accumulated WebM audio:', window.accumulatedAudioChunks.length, 'chunks');
                                // Send the accumulated audio as a complete file
                                const completeWebM = new Blob(window.accumulatedAudioChunks, { type: 'audio/webm;codecs=opus' });
                                
                                const reader = new FileReader();
                                reader.onload = function() {
                                    const arrayBuffer = reader.result;
                                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                                    
                                    const endpoint = `/api/calls/${currentCallId}/phone-audio`;
                                    console.log('=== SENDING ACCUMULATED AUDIO FROM LOOP ===');
                                    console.log('Accumulated WebM size:', completeWebM.size, 'bytes');
                                    
                                    fetch(endpoint, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ 
                                            audio_data: base64Audio,
                                            source: 'caller',
                                            for_recording: true,
                                            is_complete_file: true
                                        })
                                    })
                                    .then(response => {
                                        // Check if the call was terminated (404 response)
                                        if (response.status === 404) {
                                            console.log('ðŸ›‘ Call terminated by server (404 response), stopping audio loop');
                                            clearInterval(audioSendingInterval);
                                            callActive = false;
                                            currentCallId = null;
                                            return response.json();
                                        }
                                        return response.json();
                                    })
                                    .then(data => {
                                        if (data && data.success) {
                                            console.log(`âœ… Accumulated audio sent from loop: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                                            window.accumulatedAudioChunks = []; // Reset chunks
                                            window.lastAudioSendTime = Date.now();
                                        } else if (data && data.error) {
                                            console.error('Accumulated audio failed:', data.error);
                                        }
                                    })
                                    .catch(error => {
                                        console.error('Error sending accumulated audio:', error);
                                    });
                                };
                                reader.readAsArrayBuffer(completeWebM);
                                
                                audioSent = true;
                            } else {
                                console.log('ðŸŽ¤ Audio chunks available but not yet accumulated. Current chunks:', audioChunks.length);
                                // Process the latest chunk to add to accumulation
                                if (audioChunks.length > 0) {
                                    const latestChunk = audioChunks[audioChunks.length - 1];
                                    sendAudioChunk(latestChunk);
                                    audioSent = true;
                                }
                            }
                        } else {
                            console.log('No audio chunks available from MediaRecorder');
                        }
                        
                        // Method 2: Generate realistic audio data as fallback (ONLY if no real audio was sent)
                        if (!audioSent) {
                            console.log('âš ï¸  No real audio available, sending generated audio as fallback');
                            console.log('âš ï¸  Audio source: Generated (synthetic speech-like audio)');
                            generateAndSendRealAudio();
                        } else {
                            console.log('âœ… Real microphone audio sent successfully');
                        }
                        
                    } catch (error) {
                        console.error('âŒ Error in audio sending loop:', error);
                        // Only fallback to generated audio if there's an error
                        console.log('âŒ Error occurred, sending generated audio as emergency fallback');
                        generateAndSendRealAudio();
                    }
                    
                }, 200); // Send every 200ms for continuous recording
                
                // Store interval reference for cleanup
                window.audioSendingInterval = audioSendingInterval;
                console.log('ðŸŽ¤ Periodic audio sending started - will capture real microphone audio');
            }, 500); // Wait 500ms for MediaRecorder to start capturing
        }
        
        // Send audio chunk to server using unauthenticated endpoint
        function sendAudioChunk(audioChunk) {
            // CRITICAL: Double-check call status before sending
            if (!currentCallId || !callActive || !audioChunk || audioChunk.size === 0) {
                console.log('ðŸ›‘ Cannot send audio: Call inactive or invalid chunk');
                return;
            }
            
            console.log('=== SENDING AUDIO CHUNK ===');
            console.log('Current Call ID:', currentCallId);
            console.log('Audio chunk size:', audioChunk.size, 'bytes');
            
            // Initialize accumulated audio array if it doesn't exist
            if (!window.accumulatedAudioChunks) {
                window.accumulatedAudioChunks = [];
            }
            
            // Add chunk to accumulated audio
            window.accumulatedAudioChunks.push(audioChunk);
            console.log('ðŸŽ¤ Added chunk to accumulated audio. Total chunks:', window.accumulatedAudioChunks.length);
            
            // Only send when we have enough chunks or every 2 seconds
            if (!window.lastAudioSendTime) {
                window.lastAudioSendTime = Date.now();
            }
            
            const timeSinceLastSend = Date.now() - window.lastAudioSendTime;
            const shouldSend = timeSinceLastSend >= 2000 || window.accumulatedAudioChunks.length >= 5;
            
            if (shouldSend && window.accumulatedAudioChunks.length > 0) {
                // Create a complete WebM blob from accumulated chunks
                const completeWebM = new Blob(window.accumulatedAudioChunks, { type: 'audio/webm;codecs=opus' });
                
                const reader = new FileReader();
                reader.onload = function() {
                    const arrayBuffer = reader.result;
                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                    
                    const endpoint = `/api/calls/${currentCallId}/phone-audio`;
                    console.log('=== SENDING COMPLETE WEBM TO ENDPOINT:', endpoint, '===');
                    console.log('Complete WebM size:', completeWebM.size, 'bytes');
                    console.log('Chunks used:', window.accumulatedAudioChunks.length);
                    
                    // Send to server using unauthenticated endpoint
                    fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            audio_data: base64Audio,
                            source: 'caller',
                            for_recording: true,
                            is_complete_file: true
                        })
                    })
                    .then(response => {
                        // Check if the call was terminated (404 response)
                        if (response.status === 404) {
                            console.log('ðŸ›‘ Call terminated by server (404 response), stopping audio sending');
                            callActive = false;
                            currentCallId = null;
                            return response.json();
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            console.log(`âœ… Complete WebM audio sent: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                            // Reset accumulated chunks after successful send
                            window.accumulatedAudioChunks = [];
                            window.lastAudioSendTime = Date.now();
                        } else if (data && data.error) {
                            console.error('Audio recording failed:', data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error sending audio for recording:', error);
                    });
                };
                reader.readAsArrayBuffer(completeWebM);
            }
        }
        
        // Generate and send realistic audio data using unauthenticated endpoint
        function generateAndSendRealAudio() {
            // CRITICAL: Double-check call status before sending
            if (!currentCallId || !callActive) {
                console.log('ðŸ›‘ Cannot send generated audio: Call inactive');
                return;
            }
            
            // Additional safety check: verify call status in DOM
            const callStatusElement = document.getElementById('callStatus');
            if (!callStatusElement || callStatusElement.textContent === 'Call Ended') {
                console.log('ðŸ›‘ Call status indicates call ended, stopping audio generation');
                callActive = false;
                currentCallId = null;
                return;
            }
            
            console.log('=== GENERATING AND SENDING REAL AUDIO ===');
            console.log('Current Call ID:', currentCallId);
            console.log('Call Active:', callActive);
            
            // Generate 200ms of realistic audio data (speech-like patterns)
            const sampleRate = 44100;
            const duration = 0.2; // 200ms
            const samples = Math.floor(sampleRate * duration);
            
            // Create varying frequency content to simulate speech
            const realAudio = [];
            for (let i = 0; i < samples; i++) {
                const time = i / sampleRate;
                
                // Mix multiple frequencies with varying patterns
                const freq1 = 200 + 150 * Math.sin(time * 1.5); // Base frequency
                const freq2 = 600 + 200 * Math.sin(time * 2.3); // Mid frequency  
                const freq3 = 1000 + 300 * Math.sin(time * 1.8); // High frequency
                
                const sample1 = 0.25 * Math.sin(2 * Math.PI * freq1 * time);
                const sample2 = 0.15 * Math.sin(2 * Math.PI * freq2 * time);
                const sample3 = 0.1 * Math.sin(2 * Math.PI * freq3 * time);
                
                // Add some noise to make it more realistic
                const noise = (Math.random() - 0.5) * 0.05;
                
                const combinedSample = sample1 + sample2 + sample3 + noise;
                const intSample = Math.floor(combinedSample * 16384); // 16-bit
                
                // Ensure sample is within valid range
                const clampedSample = Math.max(-32768, Math.min(32767, intSample));
                
                realAudio.push(clampedSample & 0xFF, (clampedSample >> 8) & 0xFF);
            }
            
            const audioBytes = new Uint8Array(realAudio);
            const base64Audio = btoa(String.fromCharCode(...audioBytes));
            
            const endpoint = `/api/calls/${currentCallId}/phone-audio`;
            console.log('=== SENDING TO ENDPOINT:', endpoint, '===');
            console.log('Audio data size:', audioBytes.length, 'bytes');
            
            // Send to server using unauthenticated endpoint
            fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    audio_data: base64Audio,
                    source: 'caller',
                    for_recording: true
                })
            })
            .then(response => {
                // Check if the call was terminated (404 response)
                if (response.status === 404) {
                    console.log('ðŸ›‘ Call terminated by server (404 response), stopping audio generation');
                    callActive = false;
                    currentCallId = null;
                    return response.json();
                }
                return response.json();
            })
            .then(data => {
                if (data && data.success) {
                    console.log(`Real audio sent: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                } else if (data && data.error) {
                    console.error('Real audio failed:', data.error);
                }
            })
            .catch(error => {
                console.error('Error sending real audio:', error);
            });
        }

        // NEW: Proper audio recording system for calls
        let callAudioRecorder = null;
        let callAudioChunks = [];
        let isRecordingCall = false;

        // Initialize call audio recorder
        function initializeCallAudioRecorder() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('MediaDevices API not supported');
                return false;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                        ? 'audio/webm;codecs=opus' 
                        : 'audio/webm';
                    
                    callAudioRecorder = new MediaRecorder(stream, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 128000
                    });
                    
                    callAudioRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            callAudioChunks.push(event.data);
                        }
                    };
                    
                    callAudioRecorder.onstart = () => {
                        console.log('ðŸŽ¤ Call audio recording started');
                        isRecordingCall = true;
                    };
                    
                    callAudioRecorder.onstop = () => {
                        console.log('â¹ï¸ Call audio recording stopped');
                        isRecordingCall = false;
                    };
                    
                    console.log('âœ… Call audio recorder initialized');
                })
                .catch(error => {
                    console.error('âŒ Error initializing call audio recorder:', error);
                });
        }

        // Start recording call audio
        function startCallRecording() {
            if (!callAudioRecorder) {
                initializeCallAudioRecorder();
                setTimeout(() => startCallRecording(), 100);
                return;
            }
            
            if (callAudioRecorder.state === 'inactive') {
                callAudioChunks = [];
                callAudioRecorder.start(1000); // Collect data every 1 second
                console.log('ðŸŽ¤ Call recording started');
            }
        }

        // Stop recording and send complete audio file
        function stopCallRecording() {
            if (!callAudioRecorder || callAudioRecorder.state !== 'recording') {
                return;
            }
            
            callAudioRecorder.stop();
            
            // Wait for the stop event to complete
            setTimeout(() => {
                if (callAudioChunks.length > 0) {
                    // Create complete WebM file
                    const completeWebM = new Blob(callAudioChunks, { type: 'audio/webm;codecs=opus' });
                    
                    // Convert to base64 and send to server
                    const reader = new FileReader();
                    reader.onload = function() {
                        const arrayBuffer = reader.result;
                        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                        
                        if (currentCallId) {
                            const endpoint = `/api/calls/${currentCallId}/phone-audio`;
                            console.log('=== SENDING COMPLETE CALL AUDIO ===');
                            console.log('Complete WebM size:', completeWebM.size, 'bytes');
                            
                            fetch(endpoint, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    audio_data: base64Audio,
                                    source: 'caller',
                                    for_recording: true,
                                    is_complete_file: true
                                })
                            })
                            .then(response => {
                                // Check if the call was terminated (404 response)
                                if (response.status === 404) {
                                    console.log('ðŸ›‘ Call terminated by server (404 response), stopping call audio sending');
                                    callActive = false;
                                    currentCallId = null;
                                    return response.json();
                                }
                                return response.json();
                            })
                            .then(data => {
                                if (data.success) {
                                    console.log(`Complete call audio sent: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                                    callAudioChunks = []; // Reset chunks
                                } else {
                                    console.error('Call audio recording failed:', data.error);
                                }
                            })
                            .catch(error => {
                                console.error('Error sending call audio:', error);
                            });
                        }
                    };
                    reader.readAsArrayBuffer(completeWebM);
                }
            }, 100);
        }

        // Modified: Send accumulated audio chunks periodically during call
        function sendAccumulatedAudio() {
            if (!currentCallId || !callActive || !isRecordingCall) {
                return;
            }
            
            const timeSinceLastSend = Date.now() - window.lastAudioSendTime;
            const shouldSend = timeSinceLastSend >= 5000; // Send every 5 seconds
            
            if (shouldSend && callAudioChunks.length > 0) {
                // Send accumulated chunks as a complete file
                const completeWebM = new Blob(callAudioChunks, { type: 'audio/webm;codecs=opus' });
                
                const reader = new FileReader();
                reader.onload = function() {
                    const arrayBuffer = reader.result;
                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                    
                    const endpoint = `/api/calls/${currentCallId}/phone-audio`;
                    console.log('=== SENDING ACCUMULATED AUDIO ===');
                    console.log('Accumulated WebM size:', completeWebM.size, 'bytes');
                    
                    fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            audio_data: base64Audio,
                            source: 'caller',
                            for_recording: true,
                            is_complete_file: true
                        })
                    })
                    .then(response => {
                        // Check if the call was terminated (404 response)
                        if (response.status === 404) {
                            console.log('ðŸ›‘ Call terminated by server (404 response), stopping accumulated audio sending');
                            callActive = false;
                            currentCallId = null;
                            return response.json();
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.success) {
                            console.log(`Accumulated audio sent: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                            callAudioChunks = []; // Reset chunks after successful send
                            window.lastAudioSendTime = Date.now();
                        } else if (data && data.error) {
                            console.error('Accumulated audio failed:', data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error sending accumulated audio:', error);
                    });
                };
                reader.readAsArrayBuffer(completeWebM);
            }
        }

        // Generate test audio data for simulator testing (keep as backup)
        function generateTestAudioData() {
            if (!currentCallId || !callActive) return;
            
            // Generate test audio less frequently since Recorder.js is handling real audio
            const testAudioInterval = setInterval(() => {
                if (!callActive || !currentCallId) {
                    clearInterval(testAudioInterval);
                    return;
                }
                
                // Send request to generate test audio on server (as backup)
                fetch(`/api/calls/${currentCallId}/generate-test-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Only log occasionally to avoid spam
                        if (Math.random() < 0.1) { // Log 10% of the time
                            console.log(`Backup test audio generated: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                        }
                    } else {
                        console.error('Test audio generation failed:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error generating test audio:', error);
                });
            }, 2000); // Generate backup test audio every 2 seconds
            
            // Store interval reference for cleanup
            window.testAudioInterval = testAudioInterval;
        }

        // Answer call function
        function answerCall() {
            if (!currentCallId) {
                showStatus('No call to answer', 'warning');
                return;
            }

            showStatus('Answering call...', 'info');
            
            fetch(`/api/calls/${currentCallId}/answer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    callActive = true;
                    showStatus('Call answered! Speak into your microphone.', 'success');
                    document.getElementById('answerBtn').style.display = 'none';
                    document.getElementById('hangupBtn').style.display = 'inline-block';
                    
                    // Start call audio recording
                    startCallRecording();
                    
                    // Start periodic audio sending
                    window.lastAudioSendTime = Date.now();
                    setInterval(sendAccumulatedAudio, 1000); // Check every second
                    
                    console.log('Call answered successfully');
                } else {
                    showStatus('Failed to answer call: ' + data.error, 'danger');
                }
            })
            .catch(error => {
                console.error('Error answering call:', error);
                showStatus('Error answering call', 'danger');
            });
        }

        // Hangup call function
        function hangupCall() {
            if (!currentCallId) {
                showStatus('No call to hang up', 'warning');
                return;
            }

            showStatus('Hanging up call...', 'info');
            
            // Stop call audio recording first
            stopCallRecording();
            
            // Stop the audio sending loop
                if (window.audioSendingInterval) {
                    clearInterval(window.audioSendingInterval);
                    window.audioSendingInterval = null;
                }
                
            // Stop test audio generation
            if (window.testAudioInterval) {
                clearInterval(window.testAudioInterval);
                window.testAudioInterval = null;
            }
            
            fetch(`/api/calls/${currentCallId}/hangup`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                callActive = false;
                    currentCallId = null;
                    showStatus('Call ended', 'info');
                    
                    // Safely update UI elements with null checks
                    const answerBtn = document.getElementById('answerBtn');
                    const hangupBtn = document.getElementById('hangupBtn');
                    const callBtn = document.getElementById('callBtn');
                    const dialPad = document.getElementById('dialPad');
                    const forceAudioBtn = document.getElementById('forceAudioBtn');
                    
                    if (answerBtn) answerBtn.style.display = 'inline-block';
                    if (hangupBtn) hangupBtn.style.display = 'none';
                    if (callBtn) callBtn.style.display = 'block';
                    if (dialPad) dialPad.style.display = 'grid';
                    if (forceAudioBtn) forceAudioBtn.style.display = 'none';
                    
                    // Stop call audio recording
                    if (callAudioRecorder && callAudioRecorder.state === 'recording') {
                        callAudioRecorder.stop();
                    }
                    
                    // Clear accumulated audio
                    if (window.accumulatedAudioChunks) {
                        window.accumulatedAudioChunks = [];
                    }
                    if (audioChunks) {
                        audioChunks = [];
                    }
                    
                    console.log('Call hung up successfully');
                        } else {
                    showStatus('Failed to hang up call: ' + data.error, 'danger');
                        }
                    })
                    .catch(error => {
                        console.error('Error hanging up call:', error);
                showStatus('Error hanging up call', 'danger');
            });
        }

        // End call interface
        function endCall() {
            console.log('ðŸ›‘ Ending call and cleaning up resources...');
            
            callActive = false;
            recording = false;
            currentCallId = null;
            
            // Stop all audio sending loops
            if (window.audioSendingInterval) {
                clearInterval(window.audioSendingInterval);
                window.audioSendingInterval = null;
            }
            
            if (window.testAudioInterval) {
                clearInterval(window.testAudioInterval);
                window.testAudioInterval = null;
            }
            
            // Stop audio stream
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            // Stop call audio recorder
            if (callAudioRecorder && callAudioRecorder.state === 'recording') {
                callAudioRecorder.stop();
            }
            
            // Clear all audio data
            if (window.accumulatedAudioChunks) {
                window.accumulatedAudioChunks = [];
            }
            if (audioChunks) {
                audioChunks = [];
            }
            if (callAudioChunks) {
                callAudioChunks = [];
            }
            
            // Update UI with null checks
            const callStatus = document.getElementById('callStatus');
            const callTimer = document.getElementById('callTimer');
            const audioVisualizer = document.getElementById('audioVisualizer');
            const audioControls = document.getElementById('audioControls');
            const recordingIndicator = document.getElementById('recordingIndicator');
            const callBtn = document.getElementById('callBtn');
            const recordBtn = document.getElementById('recordBtn');
            const muteBtn = document.getElementById('muteBtn');
            const hangupBtn = document.getElementById('hangupBtn');
            const dialPad = document.getElementById('dialPad');
            const forceAudioBtn = document.getElementById('forceAudioBtn');
            
            if (callStatus) callStatus.textContent = 'Call Ended';
            if (callStatus) callStatus.className = 'call-status status-ended';
            if (callTimer) callTimer.style.display = 'none';
            if (audioVisualizer) audioVisualizer.style.display = 'none';
            if (audioControls) audioControls.style.display = 'none';
            if (recordingIndicator) recordingIndicator.style.display = 'none';
            
            // Reset controls
            if (callBtn) callBtn.style.display = 'block';
            if (recordBtn) recordBtn.style.display = 'none';
            if (muteBtn) muteBtn.style.display = 'none';
            if (hangupBtn) hangupBtn.style.display = 'none';
            if (dialPad) dialPad.style.display = 'grid';
            if (forceAudioBtn) forceAudioBtn.style.display = 'none';
            
            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reinitialize audio for next call
            setTimeout(async () => {
                await initializeAudio();
            }, 1000);
            
            // Reset to ready state after 3 seconds
            setTimeout(() => {
                if (callStatus) {
                    callStatus.textContent = 'Ready to Call';
                    callStatus.className = 'call-status status-calling';
                }
            }, 3000);
            
            console.log('âœ… Call cleanup completed');
        }

        // Toggle recording
        async function toggleRecording() {
            if (!callActive || !currentCallId) return;
            
            if (!recording) {
                await startRecording();
            } else {
                await stopRecording();
            }
        }

        // Start recording
        async function startRecording() {
            if (!recorder) {
                showStatus('Audio recorder not available', 'warning');
                return;
            }
            
            try {
                // Start recording in the VOIP system
                const response = await fetch(`/api/calls/${currentCallId}/start-recording`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    recording = true;
                    document.getElementById('recordingIndicator').style.display = 'block';
                    document.getElementById('recordBtn').style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                    showStatus('Recording started', 'success');
                    
                    console.log('Manual recording started with Recorder.js');
                    
                } else {
                    showStatus('Recording failed: ' + data.error, 'danger');
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                showStatus('Recording failed: ' + error.message, 'danger');
            }
        }

        // Stop recording
        async function stopRecording() {
            if (!recording || !currentCallId) return;
            
            try {
                // Stop recording in the VOIP system
                const response = await fetch(`/api/calls/${currentCallId}/stop-recording`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    recording = false;
                    document.getElementById('recordingIndicator').style.display = 'none';
                    document.getElementById('recordBtn').style.background = 'linear-gradient(45deg, #8e44ad, #9b59b6)';
                    
                    const message = `Recording stopped and saved (${data.audio_frames_count} frames, ${data.file_size} bytes)`;
                    showStatus(message, 'success');
                    
                    console.log('Manual recording stopped:', data);
                } else {
                    showStatus('Stop recording failed: ' + data.error, 'danger');
                }
            } catch (error) {
                console.error('Error stopping recording:', error);
                showStatus('Stop recording failed: ' + error.message, 'danger');
            }
        }

        // Toggle mute
        function toggleMute() {
            muted = !muted;
            const muteBtn = document.getElementById('muteBtn');
            
            if (muted) {
                muteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                muteBtn.style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                showStatus('Microphone muted', 'info');
                
                // Mute audio stream
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => track.enabled = false);
                }
                
                // Pause Recorder.js if active
                if (recorder && callActive) {
                    recorder.pause();
                }
            } else {
                muteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                muteBtn.style.background = 'linear-gradient(45deg, #34495e, #2c3e50)';
                showStatus('Microphone unmuted', 'info');
                
                // Unmute audio stream
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => track.enabled = true);
                }
                
                // Resume Recorder.js if active
                if (recorder && callActive) {
                    recorder.resume();
                }
            }
        }

        // Dial number
        function dialNumber(digit) {
            const phoneInput = document.getElementById('phoneNumber');
            phoneInput.value += digit;
            
            // Play dial tone sound (simulated)
            console.log('Dialed:', digit);
        }

        // Start call timer
        function startTimer() {
            timerInterval = setInterval(() => {
                if (callStartTime) {
                    const elapsed = new Date() - callStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('callTimer').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        // Start audio visualizer animation
        function startAudioVisualizer() {
            const bars = document.querySelectorAll('.audio-bar');
            setInterval(() => {
                if (callActive && !muted) {
                    bars.forEach(bar => {
                        const height = Math.random() * 40 + 10;
                        bar.style.height = height + 'px';
                    });
                }
            }, 200);
        }

        // Show status message
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `alert alert-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // Clear phone number
        function clearNumber() {
            document.getElementById('phoneNumber').value = '';
        }

        // Simple microphone test function
        async function testMicrophoneSimple() {
            console.log('ðŸŽ¤ Testing microphone access...');
            
            try {
                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    showStatus('Microphone API not supported in this browser', 'warning');
                    return;
                }
                
                // Request microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    } 
                });
                
                console.log('âœ… Microphone access granted');
                showStatus('Microphone access granted! Testing recording...', 'success');
                
                // Create a simple MediaRecorder for testing
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                    ? 'audio/webm;codecs=opus' 
                    : 'audio/webm';
                
                const testRecorder = new MediaRecorder(stream, { 
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000
                });
                
                const testChunks = [];
                
                testRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        testChunks.push(event.data);
                        console.log(`ðŸŽ¤ Test audio chunk: ${event.data.size} bytes`);
                    }
                };
                
                testRecorder.onstart = () => {
                    console.log('ðŸŽ¤ Test recording started');
                    showStatus('Recording test audio - speak now...', 'info');
                };
                
                testRecorder.onstop = () => {
                    console.log('â¹ï¸ Test recording stopped');
                    
                    if (testChunks.length > 0) {
                        const totalSize = testChunks.reduce((sum, chunk) => sum + chunk.size, 0);
                        showStatus(`Microphone test successful! Captured ${testChunks.length} chunks, ${totalSize} bytes`, 'success');
                        
                        // Create and play the test audio
                        const audioBlob = new Blob(testChunks, { type: mimeType });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio(audioUrl);
                        
                        audio.play();
                        showStatus('Playing test recording...', 'info');
                        
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            showStatus('Test recording playback finished!', 'success');
                        };
                    } else {
                        showStatus('No audio captured during test', 'warning');
                    }
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };
                
                // Start recording for 3 seconds
                testRecorder.start();
                
                setTimeout(() => {
                    if (testRecorder.state === 'recording') {
                        testRecorder.stop();
                    }
                }, 3000);
                
            } catch (error) {
                console.error('âŒ Microphone test failed:', error);
                if (error.name === 'NotAllowedError') {
                    showStatus('Microphone access denied. Please allow microphone access and try again.', 'warning');
                } else if (error.name === 'NotFoundError') {
                    showStatus('No microphone found. Please connect a microphone and try again.', 'warning');
                } else {
                    showStatus('Microphone test failed: ' + error.message, 'danger');
                }
            }
        }

        // Test microphone to verify real audio capture
        function testMicrophone() {
            if (!recorder || !recorder.mediaRecorder) {
                showStatus('Microphone not initialized', 'warning');
                return;
            }
            
            try {
                // Start recording for a short test
                recorder.start();
                showStatus('Testing microphone - speak now...', 'info');
                
                // Stop after 2 seconds
                setTimeout(() => {
                    if (recorder.isRecording) {
                        recorder.stop();
                        
                        // Check if we captured any audio
                        if (audioChunks && audioChunks.length > 0) {
                            const totalSize = audioChunks.reduce((sum, chunk) => sum + chunk.size, 0);
                            showStatus(`Microphone test successful! Captured ${audioChunks.length} chunks, ${totalSize} bytes`, 'success');
                            console.log('Microphone test successful:', audioChunks.length, 'chunks,', totalSize, 'bytes');
                            
                            // Test sending one chunk to verify the endpoint works
                            if (audioChunks.length > 0) {
                                const testChunk = audioChunks[0];
                                console.log('Testing real audio chunk:', testChunk.size, 'bytes');
                                
                                // Send test chunk to verify real audio works
                                if (currentCallId && callActive) {
                                    sendAudioChunk(testChunk);
                                    console.log('Test chunk sent to verify real audio recording');
                                }
                            }
                        } else {
                            showStatus('Microphone test failed - no audio captured', 'warning');
                            console.warn('Microphone test failed - no audio chunks captured');
                        }
                        
                        // Clear test chunks
                        audioChunks = [];
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Error testing microphone:', error);
                showStatus('Microphone test failed: ' + error.message, 'danger');
            }
        }

        // Force real audio generation for testing
        function forceRealAudio() {
            if (!currentCallId || !callActive) return;
            
            console.log('Forcing real audio generation...');
            
            // Generate realistic audio data (simulating speech patterns)
            const sampleRate = 44100;
            const duration = 0.5; // 500ms
            const samples = Math.floor(sampleRate * duration);
            const realAudio = [];
            
            // Generate varying frequency content to simulate speech
            for (let i = 0; i < samples; i++) {
                const time = i / sampleRate;
                // Mix multiple frequencies to simulate speech
                const freq1 = 200 + 100 * Math.sin(time * 2); // Varying base frequency
                const freq2 = 800 + 200 * Math.sin(time * 3); // Mid frequency
                const freq3 = 1200 + 300 * Math.sin(time * 1.5); // High frequency
                
                const sample1 = 0.3 * Math.sin(2 * Math.PI * freq1 * time);
                const sample2 = 0.2 * Math.sin(2 * Math.PI * freq2 * time);
                const sample3 = 0.1 * Math.sin(2 * Math.PI * freq3 * time);
                
                const combinedSample = sample1 + sample2 + sample3;
                const intSample = Math.floor(combinedSample * 16384); // 16-bit
                realAudio.push(intSample & 0xFF, (intSample >> 8) & 0xFF);
            }
            
            const audioBytes = new Uint8Array(realAudio);
            const base64Audio = btoa(String.fromCharCode(...audioBytes));
            
            // Send to server using unauthenticated endpoint
            fetch(`/api/calls/${currentCallId}/phone-audio`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    audio_data: base64Audio,
                    source: 'caller',
                    for_recording: true
                })
            })
            .then(response => {
                // Check if the call was terminated (404 response)
                if (response.status === 404) {
                    console.log('ðŸ›‘ Call terminated by server (404 response), stopping forced audio');
                    callActive = false;
                    currentCallId = null;
                    return response.json();
                }
                return response.json();
            })
            .then(data => {
                if (data && data.success) {
                    console.log(`Forced real audio sent: ${data.frames_count} frames, ${data.total_bytes} bytes`);
                    showStatus('Real audio generated and sent', 'success');
                } else if (data && data.error) {
                    console.error('Forced audio failed:', data.error);
                }
            })
            .catch(error => {
                console.error('Error sending forced audio:', error);
            });
        }

        // Test recording for 5 seconds
        function testRecording() {
            if (!recorder || !recorder.mediaRecorder) {
                showStatus('Main recorder not available, trying simple microphone test...', 'info');
                testMicrophoneSimple();
                return;
            }

            try {
                // Start recording for 5 seconds
                const startTime = Date.now();
                const duration = 5000; // 5 seconds
                const interval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed >= duration) {
                        clearInterval(interval);
                        recorder.stop();
                        showStatus('5-second recording test complete. Click "Play Test Audio" to hear it!', 'success');
                        console.log('5-second recording test complete.');
                        
                        // Show the play button
                        document.getElementById('playTestBtn').style.display = 'inline-block';
                    }
                }, 100); // Check every 100ms

                recorder.start();
                showStatus('5-second recording test started...', 'info');
                console.log('5-second recording test started.');

            } catch (error) {
                console.error('Error starting 5-second recording test:', error);
                showStatus('Error starting 5-second recording test: ' + error.message, 'danger');
            }
        }

        // Play test recording audio
        function playTestRecording() {
            if (!recorder || !recorder.mediaRecorder) {
                showStatus('No test recording data available', 'warning');
                return;
            }

            try {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.play();
                showStatus('Playing test recording...', 'info');
                console.log('Playing test recording audio.');

                // Clean up the audio URL after playback
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    showStatus('Test recording playback finished.', 'info');
                };

            } catch (error) {
                console.error('Error playing test recording audio:', error);
                showStatus('Error playing test recording audio: ' + error.message, 'danger');
            }
        }

        // Show playback button for the latest recording
        function showPlaybackButton(callId) {
            const playbackBtn = document.createElement('button');
            playbackBtn.className = 'btn btn-outline-light btn-sm ms-2';
            playbackBtn.innerHTML = '<i class="fas fa-play"></i> Play Latest Recording';
            playbackBtn.onclick = () => {
                playLatestRecording(callId);
            };
            playbackBtn.style.display = 'inline-block';
            document.getElementById('testControls').appendChild(playbackBtn); // Append to test controls
        }

        // Play the latest recording for a specific call ID
        async function playLatestRecording(callId) {
            try {
                const response = await fetch(`/api/calls/${callId}/get-latest-recording`);
                const data = await response.json();

                if (data.success && data.audio_url) {
                    const audioUrl = data.audio_url;
                    const audio = new Audio(audioUrl);
                    audio.play();
                    showStatus('Playing latest recording...', 'info');
                    console.log('Playing latest recording from call ID:', callId);

                    audio.onended = () => {
                        showStatus('Latest recording playback finished.', 'info');
                    };
                } else {
                    showStatus('No recording found for this call.', 'warning');
                    console.warn('No recording found for call ID:', callId);
                }
            } catch (error) {
                console.error('Error fetching or playing latest recording:', error);
                showStatus('Error playing latest recording: ' + error.message, 'danger');
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Phone simulator page loaded');
            
            // Initialize main audio system (this creates the recorder object)
            initializeAudio();
            
            // Initialize call audio recorder
            initializeCallAudioRecorder();
            
            // Set up WebSocket connection
            setupWebSocket();
            
            // Initialize other components
            initializeDialPad();
            initializeAudioVisualizer();
            
            // Show initial status
            showStatus('Ready to make calls', 'info');
        });
    </script>
</body>
</html> 